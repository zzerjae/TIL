# 프로그래밍과 인지 부하

> [Programming and Cognitive Load - Jamie Matthews](https://www.dabapps.com/blog/cognitive-load-programming/)를 읽고 요약 정리한 내용.

- 인지 부하는 문제 해결 과정에서의 인지적 요구량을 말한다. 어떤 정보를 학습할 때는, 작동 기억 안에서 정보가 처리되어야하는데, 작동 기억이 처리해낼 수 있는 정보의 양보다 처리해야 할 양이 많으면, 인지부하가 생긴다.

- 인지 심리학에서 영감을 얻어 더 나은 코드를 작성하도록 하기 위한 글이다.

- "프로그램은 사람이 읽을 수 있게 쓰여져야 한다. 기계가 이를 실행하는 것은 부차적인 일이다."라고 소프트웨어 공학에서 말한다.

- 이게 실제로 어떤 것을 말하는 걸까?

- 표면적으로 모든 개발자가 따라야할 간단한 규칙이 있다.
  - 좋은 변수명과 함수 이름 짓기
  - 코드를 적절하게 포맷팅하기
  - 관련이 있는, 부차적이지 않은 코멘트 작성

- 하지만, 가독성과 유지보수성을 늘리기 위한 탐색은 이보다 좀더 깊은 레벨에서 해석될 여지가 있다.

- 우리가 읽을 때 정보를 어떻게 처리하는가, 즉 우리의 마음이 어떻게 동작할지에 대해서 고려해야 한다.

- 이러한 방식의 접근에서 도출된 결론은 코드를 작성할 때, 전통적인 통념과 다를 수 있다.

- 저자는 심리학자가 아니며, 이 글은 학술적 논문이 아니다. 그저 비유적으로 접근하는 것이다. 이렇게 생각해보는게 도움이 될 수도 있다는 것이지 과학적인 측면에서 엄격한 사실에 기반한 서술이 아니다.


### 인지 부하가 뭘까

- 인지 부하는 인지 심리학 용어로, 학습에 관련된 용어다. 작동 기억에서 사용되는 노력의 양을 측정하는 것이다.

- 작동 기억은 쉽게 말해서, 개개인이 현재 하고있는 것에 관련된 정보를 처리하는 인지 시스템의 한 부분이다. 장기 기억에 반대되는데, 장기 기억은 구조화된 지식을 얻는 것이다.

- 우리는 작동 기억이 한정되어 있고, 과부하에 취약한 것을 알고 있다. (전화 번호를 한번만 듣고 기억해내봐)

- 프로그래밍과 버그를 따라 추적하는 것은 작동 기억과 매우 관련 있다.

- 개발자로서, "프로그래밍을 뇌에 로딩하는 것"과 같은 느낌은 친숙하다. 이 때 작업할 알고리즘의 일부나, 데이터 모델 등을 머릿속에 떠올리고 이에 대해 탐구할 수 있다.

- 이 것은 새롭고 뭔가 익숙하지 않는 코드 조각을 볼 때 발생할 수 있다. (예를 들어 이직을 해서 일을 하기 시작할 때)

- 하지만 수년간 유지보수하고 있는 소프트웨어에 대해서도 나타날 수 있다.

- 어떠한 작은 소프트웨어라도 너무 부족해서 어떠한 개발자도 한번에 전체 시스템이 어떻게 동작하는지 이해하거나 기억해내기 힘들다.

- 그래서 뭔가 코드에 변화를 주거나 버그를 수정하기 전에는, 코드베이스의 특정 부분의 내부 동작에 친숙해질 필요가 있다.

- 소프트웨어를 유지하는 것은 본질적으로 지속적인 학습 과정이다. 그래서 인지 부하의 이론적인 토대가 적용될 수 있다.

- 인지 부하는 세가지로 나뉜다.

- 내재적 인지 부하는 과제를 배우는것 자체에 대한 어려움이다. 케이크를 만들 때, 재료들을 적절하게 무게를 재고 혼합하는데 노력이 요구된다. 적절하게 젓고, 오븐을 미리 데우고 적절한 시간동안 빵을 굽는 그런 것들이다.

- 밀접 인지 부하는 작업의 하위 부분을 설명하는 새로운 저수준을 공식화하는 노력이다.(?) 레시피의 일부는 아이싱 하는 방법에 대해 디테일하게 설병한다. 하지만, 시간이 지나 숙련된 제빵사는 어떻게 아이싱 하는지를 알기 때문에, 전체 케이크 만드는 과정의 일부로 단순하게 "아이싱하기"로 바뀐다. 즉 작업의 세부 사항을 디테일하게 설명하는 것을 말하는 것 같다.

- 외재적 인지 부하는 배우는 방식에 의해 추가되는 노력이다. 지금까지 kg, g만 써왔는데, 온스나 파운드 같은 단위를 써야한다고 생각해보자. 외재적 인지 부하는 모든 단계마다 kg에서 온스로 환산하는데 드는 시간 비용이다.

- 쉽게 말해서, 내재적 혹은 밀접 인지 부하는 좋고, 외재적은 나쁘다. 너무 많은 밀접 인지 부하는 초기의 배우는 것을 어렵고 느려지게한다. 하지만 이것은 가치 있어서 다음에 같은 일을 반복할 때, 이것은 점점 쉬워진다. 

- 내재적 인지 부하는 단지 작업을 하려면 필요한 노력일 뿐이다. 하지만 저수준의 지식과 경험이 쌓이면 점점 빨라진다.

- 외부 하중은 마찰과 같은 건데, 속도를 늦추고, 불필요한 작업으로 작동 기억을 소모한다.

- 개발자라면 직관적으로 이러한 종류들의 인지 부하가 매일매일 하는 일에 관련된 것을 알 것이다.

- 그래서 이 글에서 하는 이야기는, 나중에 코드를 읽을 사람을 위해서 내재적, 외재적, 또는 밀접 인지 부하에 미치는 영향을 고려해서 프로그래밍 구조와 추상화를 수행할 수 있다는 점입니다.

### 간단한 예시

```python
@api_view(['GET', 'POST'])
def snippet_list(request):
    """
    List all code snippets, or create a new snippet.
    """
    if request.method == 'GET':
        snippets = Snippet.objects.all()
        serializer = SnippetSerializer(snippets, many=True)
        return Response(serializer.data)

    elif request.method == 'POST':
        serializer = SnippetSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
```

- HTTP 원리만 알고 있으면 Python이나 Django를 몰라도 이해하기 쉽다. 파이썬이 빛나는 순간이다; 전문가가 아니라도 읽기 쉽다.

- 이제, 짧은 버전의 `class-based generic views`를 보자.

```python
class SnippetList(generics.ListCreateAPIView):
    queryset = Snippet.objects.all()
    serializer_class = SnippetSerializer
```

- 표면적으로 같은 일을 하지만, 훨씬 밀집되어 있다. 결정적으로 HTTP 요청이 어떻게 핸들링되는지 보다는 HTTP 요청을 자체적으로 처리하기 위해 프레임워크를 설정하는 방법을 선언한다.

- 이 것은 코드를 읽는 사람이 `ListCreateAPIView`가 어떻게 동작하는지 미리 알아야 한다.

- `serializer class`가 뭐지? 시리얼라이저가 실제로 만들어지고 사용된 첫 번째 예제가 후자에 없는 많은 단서를 준다.

- 전자는 내재적과 밀접 인지 부하의 적절한 비율을 갖고있다. 코드를 빨리 캐치할 수 있다. 후자는 실제로 이해하기 전에 많은, 거대한 컨셉을 이해하고 있오야 한다.

## 변화하기

- 소프트웨어 개발의 특징은 항상 이것이 변한다는 것이다. 완전히 예측할 수 없는 방향으로.

- 단순히 올바른 코드를 작성할 뿐만 아니라, 변화하기 쉬운 방향으로 작성해야 한다.

- create 성공에 대한 log를 추가할 때, 전자는 어디에 코드를 넣을지 알기 쉽다.

- 후자는 알기 어렵다. 코드는 줄었지만 새로운 요구에 직면했을 때, 많은 것을 알아봐야 한다.

### 추상화

- 후자의 코드의 추상화가 밀접 부하가 아니라 외재적 부하라면? 

- 반복을 피하라는 원칙을 위해서 만들어낸 추상화가 실재로는 사용하기 더 어렵고, 이해하기 어렵게 만들었다면? 

- 무엇보다, 전자에처럼 명시적으로, 저수준에서 단계 단계 플로우를 보여주는 코드보다 더, 변화하기에 어렵게 되었다면?

- 추상화로 구현한 장점이 정말 이 모든 단점을 상쇄시키는가?

- 추상화가 무조건 나쁘다는 그런 이야기는 아니다. 추상화는 모든 복잡한 소프트웨어를 지탱하는 핵심이다.

- `snippets = Snippet.objects.all()` 우리가 일하고 있는 추상화의 레벨에서, 이 코드의 의미는 명백하다. "snippets를 모두 줘." 실제로 그렇게 동작한다.

- 이 것은 외재적 부하를 줄여준다. 그렇지 않으면 데이터베이스 연결, 커서 생성, 쿼리 실행, 모델 인스턴스 생성 등 모든 과정을 수행한다.

- Django 의 ORM은 이러한 디테일을 잊고 비즈니스 로직에 집중하도록 도와준다.

### 요약

- 유지가능한 소프트웨어는 읽기 쉬운 코드에 달려 있고, 읽기 쉬운 코드는 인지 부하를 컨트롤하는데에 달려 있다.

- 성공적인 추상화는 인지 부하를 최소화한다. 특히, 외재적 인지 부하를 줄인다.

- 내재적에서 밀접 부하로 부드럽게 변환된다.

- 타자 치는 횟수를 줄이기 위해 하나의 추상화 레이어를 만드는 것이 항상 옳은 동작은 아니다.

- 대신 코드를 읽는다는 것은 본질적으로 학습 과정임을 인식해야 한다. 

- 우리가 작성한 코드 한 줄 한 줄이, 읽는 사람의 머릿 속에서 어떻게 처리될지를 고려해야 한다.

- 그러하면 이해가능하고, 유지보수 가능한 소프트웨어를 만들 수 있다.